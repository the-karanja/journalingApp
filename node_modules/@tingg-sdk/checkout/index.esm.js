import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc';
import customParseFormat from 'dayjs/plugin/customParseFormat';
import fetch$1, { Headers as Headers$1, Request, Response } from 'node-fetch';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

// TODO - Check the number of supported environments / stages
const SUPPORTED_ENVIRONMENTS = ["testing", "sandbox", "production"];
const VALID_DATE_FORMAT = "YYYY-MM-DD HH:mm:ss";
const SUPPORTED_LANGUAGES = {
    ar: "Arabic",
    fr: "French",
    en: "English",
    pt: "Portuguese",
};
const SUPPORTED_COUNTRIES = {
    MW: {
        name: "Malawi",
        country_code: "MWI",
        currency_code: "MWK",
        calling_code: "265",
        test_msisdn: "+2651800000",
    },
    KE: {
        name: "Kenya",
        country_code: "KEN",
        currency_code: "KES",
        calling_code: "254",
        test_msisdn: "+254700000000",
    },
    GH: {
        name: "Ghana",
        country_code: "GHA",
        currency_code: "GHS",
        calling_code: "233",
        test_msisdn: "+233240000000",
    },
    ZM: {
        name: "Zambia",
        country_code: "ZMB",
        currency_code: "ZMW",
        calling_code: "260",
        test_msisdn: "+260970000000",
    },
    UG: {
        name: "Uganda",
        country_code: "UGA",
        currency_code: "UGX",
        calling_code: "256",
        test_msisdn: "+256770000000",
    },
    BW: {
        name: "Botswana",
        country_code: "BWA",
        currency_code: "BWP",
        calling_code: "267",
        test_msisdn: "+2670000000",
    },
    AG: {
        name: "Angola",
        country_code: "AGO",
        currency_code: "AOA",
        calling_code: "244",
        test_msisdn: "+244921000000",
    },
    TZ: {
        name: "Tanzania",
        country_code: "TZA",
        currency_code: "TZS",
        calling_code: "255",
        test_msisdn: "+255780000000",
    },
    NG: {
        name: "Nigeria",
        country_code: "NGA",
        currency_code: "NGN",
        calling_code: "234",
        test_msisdn: "+234800000000000",
    },
    ZA: {
        name: "South Africa",
        country_code: "ZAF",
        currency_code: "ZAR",
        calling_code: "276",
        test_msisdn: "+27646000000",
    },
    CI: {
        name: "CÃ´te d'Ivoire",
        country_code: "CIV",
        currency_code: "XOF",
        calling_code: "225",
        test_msisdn: "+22555000000",
    },
};
const SUPPORTED_LANGUAGE_CODES = [...Object.keys(SUPPORTED_LANGUAGES)];
const SUPPORTED_COUNTRY_CODES = [...Object.values(SUPPORTED_COUNTRIES).map(({ country_code }) => country_code)];
const SUPPORTED_CURRENCY_CODES = [
    ...Object.values(SUPPORTED_COUNTRIES).map(({ currency_code }) => currency_code),
];
const REQUIRED_PAYLOAD_FIELDS = {
    // transaction details
    msisdn: `The msisdn provided is not valid`,
    due_date: `The due_date should be in the format ${VALID_DATE_FORMAT}`,
    account_number: `The account_number provides should be a string or number`,
    request_amount: `The request_amount should be a valid integer or float`,
    merchant_transaction_id: `The merchant_transaction_id should a valid string or number`,
    // checkout configurations
    service_code: `The service_code be a valid string`,
    country_code: `The country_code should be one of ${SUPPORTED_COUNTRY_CODES.join(",")}`,
    currency_code: `The currency_code should be one of ${SUPPORTED_CURRENCY_CODES.join(",")}`,
    // webhooks configurations
    callback_url: `The callback_url should be a valid URL`,
    fail_redirect_url: `The fail_redirect_url should be a valid URL`,
    success_redirect_url: `The success_redirect_url should be a valid URL`,
};
const OPTIONAL_PAYLOAD_FIELDS = {
    // transaction details
    customer_email: `The customer_email provided is not valid`,
    customer_last_name: `The customer_last_name should be a valid string`,
    customer_first_name: `The customer_first_name should be a valid string`,
    request_description: `The request_description should be a valid string`,
    invoice_number: `The invoice_number should be a valid string or number`,
    // checkout configurations
    prefill_msisdn: `The prefill_msisdn should be true or false`,
    payment_option_code: `The payment_option_code should a valid string`,
    language_code: `The language_code should be one of ${SUPPORTED_LANGUAGE_CODES.join(",")}`,
    charge_beneficiaries: `The charge_beneficiaries should be an array of objects with amount & charge_beneficiary_code`,
    // webhooks configurations
    pending_redirect_url: `The pending_redirect_url should be a valid URL`,
};
const EXPRESS_INPUT_ERRORS = {
    apiKey: "Apikey should be a non-empty string",
    clientId: "ClientId should be a non-empty string",
    clientSecret: "Client Secret should be an non-empty string",
    payload: "Payload should be an non-empty object",
    environment: `Environment name is not supported. Use either ${SUPPORTED_ENVIRONMENTS.toString()}`,
};
const EXPRESS_URL = {
    production: `https://checkout.tingg.africa/express/checkout`,
    testing: `https://online.uat.tingg.africa/testing/express/checkout`,
    sandbox: `https://online.sandbox.tingg.africa/approval/express/checkout`,
};
const AUTH_BASE_URL = {
    "production": "https://api.tingg.africa/v1/oauth/token/request",
    "testing": "https://api-test.tingg.africa/v1/oauth/token/request",
    "sandbox": "https://api-approval.tingg.africa/v1/oauth/token/request",
};
const API_BASE_URL = {
    "production": "https://checkout.tingg.africa/request-service/checkout-request/express-request",
    "testing": "https://online.uat.tingg.africa/testing/request-service/checkout-request/express-request",
    "sandbox": "https://online.sandbox.tingg.africa/approval/request-service/checkout-request/express-request",
};

const amount = (value) => {
    try {
        value = value.toString();
        return /^\d+(\.\d+)?$/.test(value);
    }
    catch (error) {
        return false;
    }
};
const objectLiteral = (value) => {
    return typeof value === "object" && value !== null && !Array.isArray(value);
};
const noneEmptyString = (value) => {
    return (typeof value === "string" && value.trim() !== "") || (typeof value === "number" && !isNaN(value));
};
const url = (value) => {
    try {
        new URL(value);
    }
    catch (error) {
        return false;
    }
    return true;
};
const boolean = (value) => {
    if (typeof value === "boolean")
        return true;
    if (typeof value === "string" && ["true", "false"].includes(value))
        return true;
    return false;
};
const email = (value) => {
    return /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@(([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{2,})$/i.test(value);
};
const msisdn = (value, country) => {
    var _a;
    // remove anything not a number or plus sign
    value = value.replace(/[^0-9+]/g, "");
    const callingCode = (_a = Object.values(SUPPORTED_COUNTRIES).find((item) => item["country_code"] === country)) === null || _a === void 0 ? void 0 : _a.calling_code;
    // check if it starts with the calling code
    if (callingCode === undefined)
        return false;
    if (!value.startsWith(`+${callingCode}`))
        return false;
    // Test if the MSISDN matches the E.164 format
    return /^\+[1-9]\d{1,14}$/.test(value);
};
const dueDate = (value) => {
    dayjs.extend(utc);
    dayjs.extend(customParseFormat);
    return dayjs(value, VALID_DATE_FORMAT, true).utc().isValid();
};
const countryCode = (value) => {
    return SUPPORTED_COUNTRY_CODES.includes(value);
};
const currencyCode = (value) => {
    return SUPPORTED_CURRENCY_CODES.includes(value);
};
const beneficiary = (value) => {
    if (!objectLiteral(value))
        return false;
    if (!amount(value === null || value === void 0 ? void 0 : value.amount) || !noneEmptyString(value === null || value === void 0 ? void 0 : value.charge_beneficiary_code))
        return false;
    return true;
};
const languageCode = (value) => {
    return Object.keys(SUPPORTED_LANGUAGES).includes(value);
};
var validate = (payload) => {
    // error bag
    const error = new Map();
    if (!objectLiteral(payload))
        return { error: { message: `Invalid payload. Expected an object, ${JSON.stringify(payload)} given` }, data: null };
    // REQUIRED
    for (const field in REQUIRED_PAYLOAD_FIELDS) {
        if (payload[field] === undefined) {
            const message = `The ${field} is required`;
            const value = error.has([field]) ? [...error.get([field]), message] : [message];
            error.set([field], value);
        }
    }
    if (error.size !== 0)
        return { error: Object.fromEntries(error), data: null };
    // msisdn
    const isValidPhoneNumber = msisdn(payload === null || payload === void 0 ? void 0 : payload.msisdn, payload === null || payload === void 0 ? void 0 : payload.country_code);
    if (isValidPhoneNumber === false)
        error.set("msisdn", [REQUIRED_PAYLOAD_FIELDS.msisdn]);
    // due date
    if (!dueDate(payload === null || payload === void 0 ? void 0 : payload.due_date))
        error.set("due_date", [REQUIRED_PAYLOAD_FIELDS.due_date]);
    // account number
    if (!noneEmptyString(payload === null || payload === void 0 ? void 0 : payload.account_number))
        error.set("account_number", [REQUIRED_PAYLOAD_FIELDS.account_number]);
    // request amount
    if (!amount(payload === null || payload === void 0 ? void 0 : payload.request_amount))
        error.set("request_amount", [REQUIRED_PAYLOAD_FIELDS.request_amount]);
    // merchant transaction id
    if (!noneEmptyString(payload === null || payload === void 0 ? void 0 : payload.merchant_transaction_id))
        error.set("merchant_transaction_id", [REQUIRED_PAYLOAD_FIELDS.merchant_transaction_id]);
    // service code
    if (!noneEmptyString(payload === null || payload === void 0 ? void 0 : payload.service_code))
        error.set("service_code", [REQUIRED_PAYLOAD_FIELDS.service_code]);
    // country code
    if (!countryCode(payload === null || payload === void 0 ? void 0 : payload.country_code))
        error.set("country_code", [REQUIRED_PAYLOAD_FIELDS.country_code]);
    // currency code
    if (!currencyCode(payload === null || payload === void 0 ? void 0 : payload.currency_code))
        error.set("currency_code", [REQUIRED_PAYLOAD_FIELDS.currency_code]);
    // callback_url
    if (!url(payload === null || payload === void 0 ? void 0 : payload.callback_url))
        error.set("callback_url", [REQUIRED_PAYLOAD_FIELDS.callback_url]);
    // fail_redirect_url
    if (!url(payload === null || payload === void 0 ? void 0 : payload.fail_redirect_url))
        error.set("fail_redirect_url", [REQUIRED_PAYLOAD_FIELDS.fail_redirect_url]);
    // success_redirect_url
    if (!url(payload === null || payload === void 0 ? void 0 : payload.success_redirect_url))
        error.set("success_redirect_url", [REQUIRED_PAYLOAD_FIELDS.success_redirect_url]);
    // OPTIONAL
    // customer email
    if ((payload === null || payload === void 0 ? void 0 : payload.customer_email) && !email(payload === null || payload === void 0 ? void 0 : payload.customer_email))
        error.set("customer_email", [OPTIONAL_PAYLOAD_FIELDS.customer_email]);
    // customer last name
    if ((payload === null || payload === void 0 ? void 0 : payload.customer_last_name) && !noneEmptyString(payload === null || payload === void 0 ? void 0 : payload.customer_last_name))
        error.set("customer_last_name", [OPTIONAL_PAYLOAD_FIELDS.customer_last_name]);
    // customer first name
    if ((payload === null || payload === void 0 ? void 0 : payload.customer_first_name) && !noneEmptyString(payload === null || payload === void 0 ? void 0 : payload.customer_first_name))
        error.set("customer_first_name", [OPTIONAL_PAYLOAD_FIELDS.customer_first_name]);
    // request description
    if ((payload === null || payload === void 0 ? void 0 : payload.request_description) && !noneEmptyString(payload === null || payload === void 0 ? void 0 : payload.request_description))
        error.set("request_description", [OPTIONAL_PAYLOAD_FIELDS.request_description]);
    // invoice_number
    if ((payload === null || payload === void 0 ? void 0 : payload.invoice_number) && !noneEmptyString(payload === null || payload === void 0 ? void 0 : payload.invoice_number))
        error.set("invoice_number", [OPTIONAL_PAYLOAD_FIELDS.invoice_number]);
    // prefill_msisdn
    if ((payload === null || payload === void 0 ? void 0 : payload.prefill_msisdn) && !boolean(payload === null || payload === void 0 ? void 0 : payload.prefill_msisdn))
        error.set("prefill_msisdn", [OPTIONAL_PAYLOAD_FIELDS.prefill_msisdn]);
    // payment_option_code
    if ((payload === null || payload === void 0 ? void 0 : payload.payment_option_code) && !noneEmptyString(payload === null || payload === void 0 ? void 0 : payload.payment_option_code))
        error.set("payment_option_code", [OPTIONAL_PAYLOAD_FIELDS.payment_option_code]);
    // language_code
    if ((payload === null || payload === void 0 ? void 0 : payload.language_code) && !languageCode(payload === null || payload === void 0 ? void 0 : payload.language_code))
        error.set("language_code", [OPTIONAL_PAYLOAD_FIELDS.language_code]);
    // charge_beneficiaries
    const chargeBeneficiaries = (value) => Array.isArray(value) && value.every((entry) => beneficiary(entry));
    if ((payload === null || payload === void 0 ? void 0 : payload.charge_beneficiaries) && !chargeBeneficiaries(payload === null || payload === void 0 ? void 0 : payload.charge_beneficiaries))
        error.set("charge_beneficiaries", [OPTIONAL_PAYLOAD_FIELDS.charge_beneficiaries]);
    // pending_redirect_url
    if ((payload === null || payload === void 0 ? void 0 : payload.pending_redirect_url) && !url(payload === null || payload === void 0 ? void 0 : payload.pending_redirect_url))
        error.set("pending_redirect_url", [OPTIONAL_PAYLOAD_FIELDS.pending_redirect_url]);
    return error.size !== 0 ? { error: Object.fromEntries(error), data: null } : { error: null, data: payload };
};
const isApiError = (value) => {
    return 'message' in value && 'success' in value && 'statusCode' in value;
};
const isValidationError = (value) => {
    return "status" in value && "message" in value;
};
const isUrlResponse = (value) => {
    return 'status' in value && 'results' in value;
};

const validateKey = (key) => {
    if (typeof key !== "string")
        return false;
    if (key.trim().length !== 16)
        return false;
    return true;
};
/**
 *
 * Encrypts your checkout request payload
 *
 * @param input {EncryptionInput} - An object that contains the encryption parameters
 * @param input.ivKey {EncryptionInput.ivKey} - the initialization vector from Tingg
 * @param input.secretKey {EncryptionInput.secretKey} - the secret key from Tingg
 * @param input.payload {EncryptionInput.payload} - the checkout request payload
 *
 */
const encrypt = ({ ivKey, secretKey, payload }) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const error = new Map();
        if (typeof window !== "undefined")
            return { error: { message: "This function only runs on a server, not in a browser" }, data: null };
        // validation
        if (!validateKey(ivKey))
            error.set("ivKey", new RangeError("IV key should be a 16 character string"));
        if (!validateKey(secretKey))
            error.set("secretKey", new RangeError("Secret key should be a 16 character string"));
        if (error.size !== 0)
            return { error: Object.fromEntries(error), data: null };
        const { createHash, createCipheriv } = yield import('crypto');
        const key = Buffer.from(createHash("sha256").update(secretKey).digest("hex").substring(0, 32));
        const iv = Buffer.from(createHash("sha256").update(ivKey).digest("hex").substring(0, 16));
        const cipher = createCipheriv("aes-256-cbc", key, iv);
        const encrypted = Buffer.concat([cipher.update(JSON.stringify(payload)), cipher.final()]);
        const base64String = encrypted.toString("base64");
        return {
            error: null,
            data: Buffer.from(base64String, "binary").toString("base64"),
        };
    }
    catch (error) {
        return {
            error: {
                message: (error === null || error === void 0 ? void 0 : error.message) || "Sorry, unable to encrypt payload",
            },
            data: null,
        };
    }
});

/**
 * @deprecated Replaced with {@link create} Will be removed in future
 * @param accessKey
 * @param ivKey
 * @param secretKey
 * @param payload
 * @param environment
 */
const checkout = ({ accessKey, ivKey, secretKey, payload }, environment) => __awaiter(void 0, void 0, void 0, function* () {
    const { data: validationData, error: validationError } = validate(payload);
    // return validation errors
    if (!validationData)
        return { error: validationError, data: null };
    const { data: encryptionData, error: encryptionError } = yield encrypt({ ivKey, secretKey, payload: validationData });
    // return encryption errors
    if (!encryptionData)
        return { error: encryptionError, data: null };
    const redirectURL = new URL(EXPRESS_URL[environment !== null && environment !== void 0 ? environment : "sandbox"]);
    redirectURL.searchParams.append("access_key", accessKey);
    redirectURL.searchParams.append("encrypted_payload", encryptionData);
    return { error: null, data: { access_key: accessKey, encrypted_payload: encryptionData, url: redirectURL.toString() } };
});

/**
 * Created by Kelvin Macharia on 27/03/2024
 */
if (!global.fetch) {
    // @ts-ignore
    global.fetch = fetch$1;
    // @ts-ignore
    global.Headers = Headers$1;
    // @ts-ignore
    global.Request = Request;
    // @ts-ignore
    global.Response = Response;
}

/**
 * Created by Kelvin Macharia on 12/03/2024
 */
/**
 * Request access token
 * @param apiKey
 * @param clientId
 * @param clientSecret
 * @param environment
 */
const fetchToken = (apiKey, clientId, clientSecret, environment) => __awaiter(void 0, void 0, void 0, function* () {
    const authUrl = AUTH_BASE_URL[environment !== null && environment !== void 0 ? environment : "sandbox"];
    const headers = new Headers();
    headers.append("apikey", apiKey);
    headers.append("Content-Type", "application/json");
    const data = {
        client_id: clientId,
        client_secret: clientSecret,
        grant_type: "client_credentials",
    };
    return yield fetch(authUrl, {
        method: "POST",
        headers,
        body: JSON.stringify(data),
    });
});
/**
 * Request a checkout URL
 * @param accessToken
 * @param payload
 * @param environment
 */
const expressRequest = (accessToken, payload, environment) => __awaiter(void 0, void 0, void 0, function* () {
    const checkoutUrl = API_BASE_URL[environment !== null && environment !== void 0 ? environment : "sandbox"];
    const headers = new Headers();
    headers.append("Authorization", `Bearer ${accessToken}`);
    headers.append("Content-Type", "application/json");
    const body = JSON.stringify(payload);
    return yield fetch(checkoutUrl, {
        method: "POST",
        headers,
        body,
    });
});
const services = {
    fetchToken,
    expressRequest,
};

/**
 * Create a checkout request
 *
 * Step 1: Validates input payloads
 *
 * Step 2: Fetch auth token using the provided client ID and client secret.
 *
 * Step 3: Using the returned token it sends a POST request to create checkout url using the provided payload
 * Handles various error cases including authentication failure, validation errors, and serialization
 * errors.
 *
 * In case of success, it returns the created long URL and short URL.
 *
 * @param apiKey {string} Your API KEY.
 * @param clientId {string} Your clientId used as one of the pair of credentials to create an authentication token with which requests will be authorized with.
 * @param clientSecret {string}  Your clientId used as one of the pair of credentials to create an authentication token with which requests will be authorized with.
 * @param payload {Partial<Payload>} Checkout details.
 * @param environment {Environment}
 * @returns {Promise<ExpressReturnType>} contains the data {{long_url: string, short_url: string}} and errors {string}
 *
 */
const create = ({ apiKey, clientId, clientSecret, payload }, environment) => __awaiter(void 0, void 0, void 0, function* () {
    //Validate payload is correct
    if (!noneEmptyString(apiKey)) {
        return { error: EXPRESS_INPUT_ERRORS.apiKey, data: null };
    }
    if (!noneEmptyString(clientId)) {
        return { error: EXPRESS_INPUT_ERRORS.clientId, data: null };
    }
    if (!noneEmptyString(clientSecret)) {
        return { error: EXPRESS_INPUT_ERRORS.clientSecret, data: null };
    }
    if (!objectLiteral(payload)) {
        return { error: EXPRESS_INPUT_ERRORS.payload, data: null };
    }
    if (environment !== undefined && !SUPPORTED_ENVIRONMENTS.includes(environment)) {
        return {
            error: EXPRESS_INPUT_ERRORS.environment,
            data: null,
        };
    }
    // Request access token
    const authResponse = yield services.fetchToken(apiKey, clientId, clientSecret, environment);
    // Handle auth errors
    if (authResponse.status !== 200) {
        return { error: "Authentication failed. Check your credentials, and try again.", data: null };
    }
    // Extract token from the auth response
    const auth = yield authResponse.json();
    const accessToken = auth.access_token;
    // Request a checkout URL
    const response = yield services.expressRequest(accessToken, payload, environment);
    return handleExpressResponse(response);
});
/**
 * Handle express request errors
 * @param response
 */
const handleExpressResponse = (response) => __awaiter(void 0, void 0, void 0, function* () {
    const expressResponse = yield response.json();
    // Handle auth errors
    if (response.status === 401 || (isApiError(expressResponse) && expressResponse.statusCode === 132)) {
        return { error: "Authentication failed. Invalid or expired token. Try again later.", data: null };
    }
    // Handle error with validation response
    if (response.status === 400 && isValidationError(expressResponse)) {
        return { error: `Validation failed: ${expressResponse.message}`, data: null };
    }
    // Handle serialization error
    if (response.status === 400) {
        return { error: "Serialization failed. Invalid or malformed JSON payload.", data: null };
    }
    // Handle validation errors
    if (response.status === 200 && isValidationError(expressResponse)) {
        return { error: `Validation failed: ${expressResponse.message}`, data: null };
    }
    // Handle url response and return {long_url: string, short_url: string}
    if (response.status === 200 && isUrlResponse(expressResponse)) {
        return { error: null, data: expressResponse.results };
    }
    // Fall through to returning empty data. Should never reach here
    return { error: `Request failed with status code ${response.status}. Try again later.`, data: null };
});

export { amount, beneficiary, boolean, checkout, countryCode, create, currencyCode, dueDate, email, encrypt, isApiError, isUrlResponse, isValidationError, languageCode, msisdn, noneEmptyString, objectLiteral, url };
